title:Upgrade Scripts
parent:Database Programming
sequence:600
aliases:script,scripts

<p>Upgrade Scripts perform actions on the database after a build.
   Upgrade scripts are PHP programs
   that execute at superuser privelege and are especially useful for
   populating new columns with default values or populating a new
   table from data in old tables.
</p>

<h2>Naming and Placement</h2>

<p>The recommended method for naming scripts is to use the date
   the script was finished plus a very short description of the
   feature, as in <b>2008-02-06-yamlspec.php</b> or 
   <b>2008-02-06-svnurl.php</b>.  Scripts are executed in the order
   returned by PHP's asort(), so a date-based naming system will
   cause them to run in the order they were written.
</p>

<p>Scripts are PHP programs, so they should have a PHP extension.
   A script might be named <b>2008-02-06-fillempcode.php</b>.
</p>
   
<p>Scripts should be placed into the directory application/scripts,
   as in
    <b>application/scripts/2008-02-6-fillempcode.php</b>.
</p>
    
<h2>When and How They Run</h2>

<p>Scripts run as the very last step in a build, after all other
    steps are complete.  The builder scans the scripts
    directory and makes a list of all available scripts.  Then it
    looks in the application's "scripts" table to see which have
    been marked as successfully completed.  Any script not marked
    as completed will be executed.
</p>

<p>The builder makes no attempt to determine if the script has
   run successfully.  The script must notify the builder that it
   has run ok with this command:
</p>

<pre class='prettyprint'>
$this->scriptSuccess();
</pre>

<p>If the script does not issue that command, it will be run every
   time an upgrade is performed.
</p>

<h2>Coding The Script</h2>

<p>Scripts actually execute <i>within a builder method</i>.
This means a script can refer directly to the
builder as "$this".  The basic picture of how this works is here:
</p>

<pre class='prettyprint'>
class x_builder {
    //
    // code, code, code, code....
    //
    function runScripts() {
        // 
        // code, code, code, code....
        // 
        include($script_name);
    }    
}
</pre>

<h2>Useful Builder Functions</h2>

<p>There are a handful of useful builder methods available 
   for a script to use.
</p>

<p><b>$this->SQL("UPDATE ....")</b>.  Directly issues a SQL command
    and does not return results.
</p>

<p><b>$result = $this->SQLRead("SELECT ...")</b>.  Directly issues a SQL Select
    and returns a result resource.
</p>

<p><b>$row = $this->SQLReadRow($result)</b>.  Returns one row from a 
    previous query.
</p>
    
<p><b>$rows = $this->SQLReadRows($query)</b>.  Accepts a SQL SELECT
    statement and returns the complete results.
</p>

<p><b>$this->logEntry("I am going to update the table now, please wait..")
    </b>.  Use this command to issue log entries.
</p>

<p><b>$this->scriptSuccess()</b>.  Invoke this command only when
    you are certain everything has run OK.  This command 
    records that the script has run ok, once this command is
    issued the script will never be run again.
    If this command is not run by the script then the
    script will be run on the next upgrade and so on for the next
    upgrade until the script executes this command.  
</p>

<p><b>$this->checkSuccess($scriptName)</b>.  Tells you if a previous
   script has been marked as running ok.  Use this to prevent having
   a script run if some pre-requisite has not run.

<h2>Design Ideas</h2>

<h3>Make it Rerunnable or Indempotent</h3>

<p>The fancy word for re-runnable is
   "indempotent".  In plain terms this means that if every
   command in the script
   runs twice (or 8 times or 100 times) there will be no corruption, 
   and if the script is
   stopped halfway through there will be no corruption. 
</p>

<p>Transactions are a very important aid here.  If three commands
   must execute together, wrap them in a transaction.
</p>

<p>If you are populating a new table with values from an existing
   table, check first to see if the table is populated and do 
   nothing if the table has rows already.
</p>

<h2>Scripts Are Very Dangerous</h2>

<p>The key ideas for Andromeda were born in an environment where
   upgrade scripts were a central feature of the development
   environment.  Ken Downs observed that upgrade scripts were 
   the weakest link in the entire process, for reasons too numerous
   to mention here.  Many of Andromeda's design ideas were
   motivated by Ken's desire to shrink down or eliminate the role of
   upgrade scripts.
</p>

<p>With that being said, every framework, no matter how strong it
   is, will need some way to 'escape the box' and perform actions
   that were not anticipated by the framework designers.  While
   we believe that Andromeda's database build functions implement
   a radically powerful new way to do things, we have no illusions
   that the builder can do everything any programmer might ever
   need done on an upgrade.  Upgrade scripts let the programmer
   fill the gaps.  Nevertheless, carelessly written upgrade scripts
   can ruin an otherwise beautiful day!
</p>

<span class="alert">
   <b>Broken Upgrades</b>.  Because a script is code, it can have
   bugs.  Upgrade scripts are notoriously difficult to debug because
   the programmer never runs the script more than a few times, and is 
   not likely to witness any edge cases on his well cared-for 
   dev station.  This means that errors occur <b>during an upgrade</b>,
   when the person witnessing the error may have no knowledge of
   how to fix it.  This is very much counter to the Andromeda ideal
   of having upgrades that are guaranteed to execute and complete.
</span>
   
<span class="alert"><b>Corrupted Customer Data</b>.  Scripts run at
   superuser level,
   so a command such as "truncate table customers" will run
   without complaint!
</span>

<span class="alert">
   <b>No Validation</b>.  One of the basic ideas behind Andromeda is
   that all of the business rules are expressed in a data file,  which
   makes them far more transparent than rules that are "trapped"
   in code.  This is not true for actions that occur inside of 
   scripts.  An upgrade script should never make table structure
   changes or other alterations that would invalidate the YAML
   specification.
</span>
